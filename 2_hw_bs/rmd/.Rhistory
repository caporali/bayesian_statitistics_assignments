theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
if (effectiveSize(mu.mcmc) > 1000 &
effectiveSize(tau2.mcmc) > 1000 &
effectiveSize(sigma2.mcmc) > 1000 &
prod(effectiveSize(theta.mcmc) > 1000) == 1)
{
break
}
}
}
S_mu = effectiveSize(mu.mcmc)
S_sigma2 = effectiveSize(sigma2.mcmc)
S_tau2 = effectiveSize(tau2.mcmc)
writeLines(paste("The effective sample size for mu is S_eff =", round(S_mu, 0), "\nThe effective sample size for sigma^2 is S_eff =", round(S_sigma2, 0), "\nThe effective sample size for tau^2 is S_eff =", round(S_tau2, 0), "\n"))
S_theta = effectiveSize(theta.mcmc)
S_mu = effectiveSize(mu.mcmc)
S_sigma2 = effectiveSize(sigma2.mcmc)
S_tau2 = effectiveSize(tau2.mcmc)
writeLines(paste("The effective sample size for mu is S_eff =", round(S_mu, 0), "\nThe effective sample size for sigma^2 is S_eff =", round(S_sigma2, 0), "\nThe effective sample size for tau^2 is S_eff =", round(S_tau2, 0), "\n"))
S_theta = effectiveSize(theta.mcmc)
S_mu = effectiveSize(mu.mcmc)
S_sigma2 = effectiveSize(sigma2.mcmc)
S_tau2 = effectiveSize(tau2.mcmc)
writeLines(paste("The effective sample size for mu is S_eff =", round(S_mu, 0), "\nThe effective sample size for sigma^2 is S_eff =", round(S_sigma2, 0), "\nThe effective sample size for tau^2 is S_eff =", round(S_tau2, 0), "\n"))
S_theta = effectiveSize(theta.mcmc)
knitr::opts_chunk$set(echo = TRUE)
colorize <- function(x, color) {
if (knitr::is_latex_output())
sprintf("\\textcolor{%s}{%s}", color, x)
else if (knitr::is_html_output())
sprintf('<span style = "color: %s;">%s</span>', color, x)
else x
} # `r textit("red", "aaa")`
indicator <- function() {
if (knitr::is_latex_output())
sprintf("\\indicator")
else if (knitr::is_html_output())
sprintf("1")
else sprintf("1")
} #`r indicator()`
simiid <- function() {
if (knitr::is_latex_output())
sprintf("\\simiid")
else if (knitr::is_html_output())
sprintf("\\sim")
else sprintf("\\sim")
} #`r simiid()`
newline <- function() {
if (knitr::is_latex_output())
sprintf("\\")
else if (knitr::is_html_output())
sprintf("<br>")
else ""
} # `r newline()`
textit <- function(arg) {
if (knitr::is_latex_output())
sprintf("\\textit{%s}", arg)
else if (knitr::is_html_output())
sprintf("<i>%s</i>", arg)
else sprintf("%s", arg)
} # `r textit("aaa")`
textbf <- function(arg) {
if (knitr::is_latex_output())
sprintf("\\textbf{%s}", arg)
else if (knitr::is_html_output())
sprintf("<strong>%s</strong>", arg)
else sprintf("%s", arg)
} # `r textbf("aaa")`
begin_rcases <- function() {
if (knitr::is_latex_output())
sprintf("\\begin{rcases}")
else if (knitr::is_html_output())
sprintf("\\begin{array}{l}")
else ""
} # `r begin_rcases()`
end_rcases <- function() {
if (knitr::is_latex_output())
sprintf("\\end{rcases}")
else if (knitr::is_html_output())
sprintf("\\end{array} \\hspace{0.3cm}")
else ""
} # `r end_rcases()`
cancel <- function(x) {
if (knitr::is_latex_output())
sprintf("\\cancel{%s}", x)
else if (knitr::is_html_output())
sprintf("%s", x)
else sprintf("%s", x)
} # `r cancel("x")`
library(ggplot2)
library(coda)
library(truncnorm)
load(file = "divorce.RData")
set.seed(1)
# setting parameters
burnin = 1e3
tmax = burnin + 1e5
n = 25
# build and upload: beta, c, z_1:n, y_1:n
beta = c = matrix(0, tmax, 1)
z = y = matrix(0, tmax, n)
x = matrix(0, 1, n)
x[1, ] = divorce[, "X"]
y[1, ] = divorce[, "Y"]
# parameters for priors and full conditionals distributions
mu_beta = matrix(0, tmax, 1)
mu_beta[1] = 0
mu_c = 0
sigma_sq_beta = sigma_sq_c = 16
sigma_sq_beta_n = (sum(x^2) + (sigma_sq_beta)^(-1))^(-1)
a = matrix(-Inf, tmax, 1)
b = matrix(Inf, tmax, 1)
# prior samples
beta[1] = rnorm(1, mu_beta[1], sqrt(sigma_sq_beta))
c[1] = rnorm(1, mu_c, sqrt(sigma_sq_c))
# gibbs sampler
for (t in 2:(tmax)) {
# z
lower_bound = rep(c[t - 1], n)
lower_bound[y[t - 1, ] == 0] = -Inf
upper_bound = rep(c[t - 1], n)
upper_bound[y[t - 1, ] == 1] = +Inf
z[t, ] = rtruncnorm(n, lower_bound, upper_bound, beta[t - 1] * x, rep(1, n))
# update y (redundant because they follow the behaviour of z which is sampled given y)
y[t, ] = 1 * (z[t, ] > c[t - 1])
# beta
mu_beta[t] = sigma_sq_beta_n * sum(x * z[t, ])
beta[t] = dnorm(1, mu_beta[t], sqrt(sigma_sq_beta_n))
# c
a[t] = max(z[t, ][y[t, ] == 0])
b[t] = min(z[t, ][y[t, ] == 1])
c[t] = rtruncnorm(1, a[t], b[t], mu_c, sqrt(sigma_sq_c))
# re-update y (redundant because they follow the behaviour of z which is sampled given y)
y[t, ] = 1 * (z[t, ] > c[t])
# break if eff_size > 1000 (for all params)
if (t > burnin + 1 & (t %% 1000 == 0)) {
if (effectiveSize(c[c((burnin + 1):t)]) > 1000 &
# effectiveSize(beta[c((burnin + 1):t)]) > 1000 &
prod(effectiveSize(z[c((burnin + 1):t), ]) > 1000) == 1)
{
c = c[c((burnin + 1):t)]
beta = beta[c((burnin + 1):t)]
z = z[c((burnin + 1):t), ]
break
}
}
}
# mcmc
params_mcmc = mcmc(cbind(beta, c, z))
set.seed(123)
library(coda)
library(bayesplot)
library(ggplot2)
library(gridExtra)
library(lattice)
library(grid)
library(dplyr)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(double(length = S))
mu.mcmc = mcmc(double(length = S))
tau2.mcmc = mcmc(double(length = S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
if (effectiveSize(mu.mcmc) > 1000 &
effectiveSize(tau2.mcmc) > 1000 &
effectiveSize(sigma2.mcmc) > 1000 &
prod(effectiveSize(theta.mcmc) > 1000) == 1)
{
break
}
}
}
set.seed(123)
library(coda)
library(bayesplot)
library(ggplot2)
library(gridExtra)
library(lattice)
library(grid)
library(dplyr)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(double(length = S))
mu.mcmc = mcmc(double(length = S))
tau2.mcmc = mcmc(double(length = S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin + 1){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
if (effectiveSize(mu.mcmc) > 1000 &
effectiveSize(tau2.mcmc) > 1000 &
effectiveSize(sigma2.mcmc) > 1000 &
prod(effectiveSize(theta.mcmc) > 1000) == 1)
{
break
}
}
}
S_mu = effectiveSize(mu.mcmc)
S_sigma2 = effectiveSize(sigma2.mcmc)
S_tau2 = effectiveSize(tau2.mcmc)
writeLines(paste("The effective sample size for mu is S_eff =", round(S_mu, 0), "\nThe effective sample size for sigma^2 is S_eff =", round(S_sigma2, 0), "\nThe effective sample size for tau^2 is S_eff =", round(S_tau2, 0), "\n"))
S_theta = effectiveSize(theta.mcmc)
set.seed(123)
library(coda)
library(bayesplot)
library(ggplot2)
library(gridExtra)
library(lattice)
library(grid)
library(dplyr)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(double(length = S))
mu.mcmc = mcmc(double(length = S))
tau2.mcmc = mcmc(double(length = S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
if (s %% 1000 == 0 &
effectiveSize(mu.mcmc) > 1000 &
effectiveSize(tau2.mcmc) > 1000 &
effectiveSize(sigma2.mcmc) > 1000 &
prod(effectiveSize(theta.mcmc) > 1000) == 1)
{
break
}
}
}
set.seed(123)
library(coda)
library(bayesplot)
library(ggplot2)
library(gridExtra)
library(lattice)
library(grid)
library(dplyr)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(double(length = S))
mu.mcmc = mcmc(double(length = S))
tau2.mcmc = mcmc(double(length = S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
'
if (s %% 1000 == 0 &
effectiveSize(mu.mcmc) > 1000 &
effectiveSize(tau2.mcmc) > 1000 &
effectiveSize(sigma2.mcmc) > 1000 &
prod(effectiveSize(theta.mcmc) > 1000) == 1)
{
break
}
'
}
}
S_mu = effectiveSize(mu.mcmc)
S_sigma2 = effectiveSize(sigma2.mcmc)
S_tau2 = effectiveSize(tau2.mcmc)
writeLines(paste("The effective sample size for mu is S_eff =", round(S_mu, 0), "\nThe effective sample size for sigma^2 is S_eff =", round(S_sigma2, 0), "\nThe effective sample size for tau^2 is S_eff =", round(S_tau2, 0), "\n"))
writeLines(paste("The effective sample size for theta", 1:8, "is S_eff =", round(S_theta, 0), "\n"))
S_mu = effectiveSize(mu.mcmc)
S_sigma2 = effectiveSize(sigma2.mcmc)
S_tau2 = effectiveSize(tau2.mcmc)
S_theta = effectiveSize(theta.mcmc)
writeLines(paste("The effective sample size for mu is S_eff =", round(S_mu, 0), "\nThe effective sample size for sigma^2 is S_eff =", round(S_sigma2, 0), "\nThe effective sample size for tau^2 is S_eff =", round(S_tau2, 0), "\n"))
writeLines(paste("The effective sample size for theta", 1:8, "is S_eff =", round(S_theta, 0), "\n"))
