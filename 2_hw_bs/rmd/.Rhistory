# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(0, nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(rep(0, S))
mu.mcmc = mcmc(rep(0, S))
tau2.mcmc = mcmc(rep(0, S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
#break when the chains reach the wanted effective size
if (s > burnin + 1 & (s %% 1000 == 0)) {
if (effectiveSize(mu.mcmc[1:s, drop = TRUE]) >= 1000 &
effectiveSize(tau2.mcmc[1:s, drop = TRUE]) >= 1000 &
effectiveSize(sigma2.mcmc[1:s, drop = TRUE]) >= 1000 &
prod(effectiveSize(theta.mcmc[1:s, 1:8, drop = TRUE]) >= 1000) == 1)
{
s = s - burnin
break
}
}
}
}
set.seed(1)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(0, nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(rep(0, S))
mu.mcmc = mcmc(rep(0, S))
tau2.mcmc = mcmc(rep(0, S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
#break when the chains reach the wanted effective size
if (s > burnin + 2 & (s %% 1000 == 0)) {
if (effectiveSize(mu.mcmc[1:s, drop = TRUE]) >= 1000 &
effectiveSize(tau2.mcmc[1:s, drop = TRUE]) >= 1000 &
effectiveSize(sigma2.mcmc[1:s, drop = TRUE]) >= 1000 &
prod(effectiveSize(theta.mcmc[1:s, 1:8, drop = TRUE]) >= 1000) == 1)
{
s = s - burnin
break
}
}
}
}
set.seed(1)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(0, nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(rep(0, S))
mu.mcmc = mcmc(rep(0, S))
tau2.mcmc = mcmc(rep(0, S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
#break when the chains reach the wanted effective size
if (s > burnin + 2 & (s %% 1000 == 0)) {
if (effectiveSize(mu.mcmc[1:s - burnin, drop = TRUE]) >= 1000 &
effectiveSize(tau2.mcmc[1:s - burnin, drop = TRUE]) >= 1000 &
effectiveSize(sigma2.mcmc[1:s - burnin, drop = TRUE]) >= 1000 &
prod(effectiveSize(theta.mcmc[1:s - burnin, 1:8, drop = TRUE]) >= 1000) == 1)
{
s = s - burnin
break
}
}
}
}
set.seed(1)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(0, nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(rep(0, S))
mu.mcmc = mcmc(rep(0, S))
tau2.mcmc = mcmc(rep(0, S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
#break when the chains reach the wanted effective size
if (s > burnin + 2 & (s %% 1000 == 0)) {
if (effectiveSize(mu.mcmc[1:(s - burnin), drop = TRUE]) >= 1000 &
effectiveSize(tau2.mcmc[1:(s - burnin), drop = TRUE]) >= 1000 &
effectiveSize(sigma2.mcmc[1:(s - burnin), drop = TRUE]) >= 1000 &
prod(effectiveSize(theta.mcmc[1:s - burnin, , drop = TRUE]) >= 1000) == 1)
{
s = s - burnin
break
}
}
}
}
set.seed(1)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(0, nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(rep(0, S))
mu.mcmc = mcmc(rep(0, S))
tau2.mcmc = mcmc(rep(0, S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
#break when the chains reach the wanted effective size
if (s > burnin + 2 & (s %% 1000 == 0)) {
if (effectiveSize(mu.mcmc[1:(s - burnin), drop = TRUE]) >= 1000 &
effectiveSize(tau2.mcmc[1:(s - burnin), drop = TRUE]) >= 1000 &
effectiveSize(sigma2.mcmc[1:(s - burnin), drop = TRUE]) >= 1000 &
prod(effectiveSize(theta.mcmc[1:(s - burnin), , drop = TRUE]) >= 1000) == 1)
{
s = s - burnin
break
}
}
}
}
set.seed(1)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(0, nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(rep(0, S))
mu.mcmc = mcmc(rep(0, S))
tau2.mcmc = mcmc(rep(0, S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
#break when the chains reach the wanted effective size
if (s > burnin + 2 & (s %% 1000 == 0)) {
if (effectiveSize(mu.mcmc[1:(s - burnin), drop = TRUE]) >= 1000 &
effectiveSize(tau2.mcmc[1:(s - burnin), drop = TRUE]) >= 1000 &
effectiveSize(sigma2.mcmc[1:(s - burnin), drop = TRUE]) >= 1000 &
prod(effectiveSize(theta.mcmc[1:(s - burnin), 1:8 , drop = TRUE]) >= 1000) == 1)
{
s = s - burnin
break
}
}
}
}
set.seed(1)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 1e4
theta.mcmc = mcmc(matrix(0, nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(rep(0, S))
mu.mcmc = mcmc(rep(0, S))
tau2.mcmc = mcmc(rep(0, S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
#break when the chains reach the wanted effective size
if (s > burnin + 2 & (s %% 1000 == 0)) {
if (effectiveSize(mu.mcmc) >= 1000 &
effectiveSize(tau2.mcmc) >= 1000 &
effectiveSize(sigma2.mcmc) >= 1000 &
prod(effectiveSize(theta.mcmc[1:(s - burnin), 1:8, drop = TRUE]) >= 1000) == 1)
{
s = s - burnin
break
}
}
}
}
