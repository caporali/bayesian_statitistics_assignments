prob = 0.95,
prob_outer = 1,
point_est = "mean")+
ggtitle(expression(mu))+
yaxis_text(on = FALSE)
color_scheme_set("red")
q3 <- mcmc_trace(as.data.frame(sigma2.mcmc))+
ggtitle(expression(sigma^2))+
yaxis_title(on = FALSE)
q4 <- mcmc_areas(
as.data.frame(sigma2.mcmc),
prob = 0.95,
prob_outer = 1,
point_est = "mean")+
ggtitle(expression(sigma^2))+
yaxis_text(on = FALSE)
color_scheme_set("teal")
q5 <- mcmc_trace(as.data.frame(tau2.mcmc))+
ggtitle(expression(tau^2))+
yaxis_title(on = FALSE)
q6 <- mcmc_areas(
as.data.frame(tau2.mcmc),
prob = 0.95,
prob_outer = 1,
point_est = "mean")+
ggtitle(expression(tau^2))+
yaxis_text(on = FALSE)
grid.arrange(q1, q2, q3, q4, q5, q6, nrow = 3, top=textGrob("Traceplots and density plots"))
library(invgamma)
#quantile-based 95% confidence regions for the MCMC
alpha = 0.05
a_mu = summary(mu.mcmc, quantiles= c(alpha/2, 1-alpha/2))
print(paste("The quantile-based 95%-confidence region for mu is [", a_mu$quantiles[1], ",", a_mu$quantiles[2], "] and the posterior mean is ", a_mu$statistics[1]))
a_sigma = summary(sigma2.mcmc, quantiles= c(alpha/2, 1-alpha/2))
print(paste("The quantile-based 95%-confidence region for sigma^2 is [", a_sigma$quantiles[1], ",", a_sigma$quantiles[2], "] and the posterior mean is", a_sigma$statistics[1]))
a_tau = summary(tau2.mcmc, quantiles= c(alpha/2, 1-alpha/2))
print(paste("The quantile-based 95%-confidence region for tau^2 is [", a_tau$quantiles[1], ",", a_tau$quantiles[2], "] and the posterior mean is", a_tau$statistics[1]))
#density plots comparison
x1 = seq(mu0 - 2*g20,  mu0 + 2*g20, length = 200)
x2 = seq(0.00001,  60, length = 200)
x3 = seq(a_sigma$quantiles[1] - 10,  50, length = 200)
norm_vals = dnorm(x1, mu0, g20)
invG_tau = dinvgamma(x2, eta0/2, eta0*t20/2)
invG_sigma = dinvgamma(x3, nu0/2, nu0*s20/2)
priors = data.frame(x1, x2, x3, norm_vals, invG_sigma, invG_tau)
color_scheme_set("blue")
mcmc_dens(as.data.frame(mu.mcmc), alpha = 0.5)+
xaxis_text(on = FALSE)+
ggtitle(expression(paste("Posterior distribution of ", mu))) +
geom_area(data = priors, aes(x= x1, y=norm_vals, col = "prior"),  fill = "red", alpha = 0.3, size = 0.8) +
geom_vline(aes(xintercept = a_mu$statistics[1], col = "posterior"), size = 1)+
geom_vline(aes(xintercept = mu0, col = "prior"), size = 1)+
scale_color_manual(name = "Legend", values = c("prior" = "red", "posterior" = "blue"),
labels = c("prior distribution", "posterior distribution"))
mcmc_dens(as.data.frame(tau2.mcmc), alpha = 0.5)+
xaxis_text(on = FALSE)+
ggtitle(expression(paste("Posterior distribution of ", tau^2))) +
geom_area(data = priors, aes(x= x2, y=invG_tau, col = "prior"), fill = "red", alpha = 0.3, size = 0.8) +
geom_vline(aes(xintercept = a_tau$statistics[1], col = "posterior"), size = 1)+
geom_vline(aes(xintercept = t20, col = "prior"), size = 1)+
scale_color_manual(name = "Legend", values = c("prior" = "red", "posterior" = "blue"),
labels = c("prior distribution", "posterior distribution"))
mcmc_dens(as.data.frame(sigma2.mcmc), alpha = 0.5)+
xaxis_text(on = FALSE)+
ggtitle(expression(paste("Posterior distribution of ", sigma^2))) +
geom_area(data = priors, aes(x= x3, y=invG_sigma, col = "prior"), fill = "red", alpha = 0.3, size = 0.8) +
geom_vline(aes(xintercept = a_sigma$statistics[1], col = "posterior"), size = 1)+
geom_vline(aes(xintercept = s20, col = "prior"), size = 1)+
scale_color_manual(name = "Legend", values = c("prior" = "red", "posterior" = "blue"),
labels = c("prior distribution", "posterior distribution"))
library(ggrepel)
a_theta = summary(theta.mcmc)
#print(a_theta)
#print(a_theta$statistics[1:8, 1])
post_means = a_theta$statistics[1:8, 1]
mean_plt = data.frame(post_means, ybar, names = 1:8)
mean_plt %>% ggplot(aes(x=post_means, y = ybar))+
geom_point( col = "green")+
geom_line(col = "darkgreen", alpha = 0.5)+
ylab(expression(y[i])) +
xlab(expression(paste(theta[i]))) +
ggtitle(expression(paste("Posterior mean parameters ", theta[i], " VS sample means ", y[i])))+
scale_color_discrete(guide = "none")+
geom_label_repel(aes(label = names),
box.padding   = 0.35,
point.padding = 0.5,
segment.color = 'grey50')
total.sample.mean = sum(n*ybar)/sum(n)
writeLines(paste("The total sample mean is: ", round(total.sample.mean, 2), "\nThe posterior expectation of the Grand Mean is: ", round(a_mu$statistics[1], 2), "\nSo they only differ by ", round(abs(a_mu$statistics[1] - total.sample.mean)/total.sample.mean *100, 2), "% of the former"))
a_theta = summary(theta.mcmc)
post_means = a_theta$statistics[1:8, 1]
sample.theta7 =  rep(0, S)
sample.theta9 =  rep(0, S)
for (i in 1:S){
sample.theta7[i] = rnorm(1, post_means[7], a_theta$statistics[7, 2])
sample.theta9[i] = rpois(1, mu, sqrt(sigma2 + mu$statistics[2]^2))
}
knitr::opts_chunk$set(echo = TRUE)
colorize <- function(x, color) {
if (knitr::is_latex_output())
sprintf("\\textcolor{%s}{%s}", color, x)
else if (knitr::is_html_output())
sprintf('<span style = "color: %s;">%s</span>', color, x)
else x
} # `r textit("red", "aaa")`
indicator <- function() {
if (knitr::is_latex_output())
sprintf("\\indicator")
else if (knitr::is_html_output())
sprintf("1")
else sprintf("1")
} #`r indicator()`
newline <- function() {
if (knitr::is_latex_output())
sprintf("\\")
else if (knitr::is_html_output())
sprintf("<br>")
else ""
} # `r newline()`
textit <- function(arg) {
if (knitr::is_latex_output())
sprintf("\\textit{%s}", arg)
else if (knitr::is_html_output())
sprintf("%s", arg)
else sprintf("%s", arg)
} # `r textit("aaa")`
begin_rcases <- function() {
if (knitr::is_latex_output())
sprintf("\\begin{rcases}")
else if (knitr::is_html_output())
sprintf("\\begin{array}{l}")
else ""
} # `r begin_rcases()`
end_rcases <- function() {
if (knitr::is_latex_output())
sprintf("\\end{rcases}")
else if (knitr::is_html_output())
sprintf("\\end{array} \\hspace{0.3cm}")
else ""
} # `r end_rcases()`
library(ggplot2)
set.seed(123)
library("coda")
library("bayesplot")
library("ggplot2")
library("gridExtra")
library("lattice")
library(grid)
library(dplyr)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(double(length = S))
mu.mcmc = mcmc(double(length = S))
tau2.mcmc = mcmc(double(length = S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
}
}
S_mu = effectiveSize(mu.mcmc)
S_sigma2 = effectiveSize(sigma2.mcmc)
S_tau2 = effectiveSize(tau2.mcmc)
writeLines(paste("The effective sample size for mu is S_eff =", round(S_mu, 0), "\nThe effective sample size for sigma^2 is S_eff =", round(S_sigma2, 0), "\nThe effective sample size for tau^2 is S_eff =", round(S_tau2, 0), "\n"))
S_theta = effectiveSize(theta.mcmc)
writeLines(paste("The effective sample size for theta", 1:8, "is S_eff =", round(S_theta, 0), "\n"))
#theta
color_scheme_set("blue")
p1 <- mcmc_trace(as.data.frame(theta.mcmc), pars = c("V1", "V2", "V3", "V4"), facet_args = list(nrow = 4, labeller = label_parsed))+
ggtitle(expression(paste("Traceplots of ", theta[1:4])))+
scale_y_continuous(breaks = c(4, 6, 8 ,10, 12, 14))
p2 <- mcmc_areas(as.data.frame(theta.mcmc), pars = c("V1", "V2", "V3", "V4"), prob = 0.95,
prob_outer = 1,
point_est = "mean") +
ggtitle(expression(paste("Density plots of the posteriors for ", theta[1:4])))
grid.arrange(p1, p2, nrow = 1)
p1 <- mcmc_trace(as.data.frame(theta.mcmc), pars = c("V5", "V6", "V7", "V8"), facet_args = list(nrow = 4, labeller = label_parsed))+
ggtitle(expression(paste("Traceplots of ", theta[5:8])))+
scale_y_continuous(breaks = c(4, 6, 8 ,10, 12, 14))
p2 <- mcmc_areas(as.data.frame(theta.mcmc), pars = c("V5", "V6", "V7", "V8"), prob = 0.95,
prob_outer = 1,
point_est = "mean") +
ggtitle(expression(paste("Density plots of the posteriors for ", theta[5:8])))
grid.arrange(p1, p2, nrow = 1)
#comparison
theme_update(plot.title = element_text(hjust = 0.5))
color_scheme_set("purple")
q1 <- mcmc_trace(as.data.frame(mu.mcmc))+
ggtitle(expression(mu))+
yaxis_title(on = FALSE)
q2<- mcmc_areas(
as.data.frame(mu.mcmc),
prob = 0.95,
prob_outer = 1,
point_est = "mean")+
ggtitle(expression(mu))+
yaxis_text(on = FALSE)
color_scheme_set("red")
q3 <- mcmc_trace(as.data.frame(sigma2.mcmc))+
ggtitle(expression(sigma^2))+
yaxis_title(on = FALSE)
q4 <- mcmc_areas(
as.data.frame(sigma2.mcmc),
prob = 0.95,
prob_outer = 1,
point_est = "mean")+
ggtitle(expression(sigma^2))+
yaxis_text(on = FALSE)
color_scheme_set("teal")
q5 <- mcmc_trace(as.data.frame(tau2.mcmc))+
ggtitle(expression(tau^2))+
yaxis_title(on = FALSE)
q6 <- mcmc_areas(
as.data.frame(tau2.mcmc),
prob = 0.95,
prob_outer = 1,
point_est = "mean")+
ggtitle(expression(tau^2))+
yaxis_text(on = FALSE)
grid.arrange(q1, q2, q3, q4, q5, q6, nrow = 3, top=textGrob("Traceplots and density plots"))
library(invgamma)
#quantile-based 95% confidence regions for the MCMC
alpha = 0.05
a_mu = summary(mu.mcmc, quantiles= c(alpha/2, 1-alpha/2))
print(paste("The quantile-based 95%-confidence region for mu is [", a_mu$quantiles[1], ",", a_mu$quantiles[2], "] and the posterior mean is ", a_mu$statistics[1]))
a_sigma = summary(sigma2.mcmc, quantiles= c(alpha/2, 1-alpha/2))
print(paste("The quantile-based 95%-confidence region for sigma^2 is [", a_sigma$quantiles[1], ",", a_sigma$quantiles[2], "] and the posterior mean is", a_sigma$statistics[1]))
a_tau = summary(tau2.mcmc, quantiles= c(alpha/2, 1-alpha/2))
print(paste("The quantile-based 95%-confidence region for tau^2 is [", a_tau$quantiles[1], ",", a_tau$quantiles[2], "] and the posterior mean is", a_tau$statistics[1]))
#density plots comparison
x1 = seq(mu0 - 2*g20,  mu0 + 2*g20, length = 200)
x2 = seq(0.00001,  60, length = 200)
x3 = seq(a_sigma$quantiles[1] - 10,  50, length = 200)
norm_vals = dnorm(x1, mu0, g20)
invG_tau = dinvgamma(x2, eta0/2, eta0*t20/2)
invG_sigma = dinvgamma(x3, nu0/2, nu0*s20/2)
priors = data.frame(x1, x2, x3, norm_vals, invG_sigma, invG_tau)
color_scheme_set("blue")
mcmc_dens(as.data.frame(mu.mcmc), alpha = 0.5)+
xaxis_text(on = FALSE)+
ggtitle(expression(paste("Posterior distribution of ", mu))) +
geom_area(data = priors, aes(x= x1, y=norm_vals, col = "prior"),  fill = "red", alpha = 0.3, size = 0.8) +
geom_vline(aes(xintercept = a_mu$statistics[1], col = "posterior"), size = 1)+
geom_vline(aes(xintercept = mu0, col = "prior"), size = 1)+
scale_color_manual(name = "Legend", values = c("prior" = "red", "posterior" = "blue"),
labels = c("prior distribution", "posterior distribution"))
mcmc_dens(as.data.frame(tau2.mcmc), alpha = 0.5)+
xaxis_text(on = FALSE)+
ggtitle(expression(paste("Posterior distribution of ", tau^2))) +
geom_area(data = priors, aes(x= x2, y=invG_tau, col = "prior"), fill = "red", alpha = 0.3, size = 0.8) +
geom_vline(aes(xintercept = a_tau$statistics[1], col = "posterior"), size = 1)+
geom_vline(aes(xintercept = t20, col = "prior"), size = 1)+
scale_color_manual(name = "Legend", values = c("prior" = "red", "posterior" = "blue"),
labels = c("prior distribution", "posterior distribution"))
mcmc_dens(as.data.frame(sigma2.mcmc), alpha = 0.5)+
xaxis_text(on = FALSE)+
ggtitle(expression(paste("Posterior distribution of ", sigma^2))) +
geom_area(data = priors, aes(x= x3, y=invG_sigma, col = "prior"), fill = "red", alpha = 0.3, size = 0.8) +
geom_vline(aes(xintercept = a_sigma$statistics[1], col = "posterior"), size = 1)+
geom_vline(aes(xintercept = s20, col = "prior"), size = 1)+
scale_color_manual(name = "Legend", values = c("prior" = "red", "posterior" = "blue"),
labels = c("prior distribution", "posterior distribution"))
a_theta = summary(theta.mcmc)
post_means = a_theta$statistics[1:8, 1]
sample.theta7 =  rep(0, S)
sample.theta9 =  rep(0, S)
for (i in 1:S){
sample.theta7[i] = rnorm(1, post_means[7], a_theta$statistics[7, 2])
sample.theta9[i] = rnorm(1, mu, sqrt(sigma2 + mu$statistics[2]^2))
}
a_theta = summary(theta.mcmc)
post_means = a_theta$statistics[1:8, 1]
sample.theta7 =  rep(0, S)
sample.theta9 =  rep(0, S)
for (i in 1:S){
sample.theta7[i] = rnorm(1, post_means[7], a_theta$statistics[7, 2])
sample.theta9[i] = rnorm(1, mu, sqrt(sigma2 + a_mu$statistics[2]^2))
}
mc3 = sum(sample.theta9 > sample.theta7) / S
sprintf("The Monte Carlo estimate given the original prior of theta[B] is: %f", mc3)
a_theta = summary(theta.mcmc)
post_means = a_theta$statistics[1:8, 1]
sample.theta9 =  rep(0, S)
for (i in 1:S){
sample.theta9[i] = rnorm(1, mu, sqrt(tau2.mcmc[1, i, drop = TRUE]))
y7[i] = rnorm(1, theta.mcmc[i, 7, drop = TRUE], sqrt(sigma2.mcmc[1, i, drop = TRUE]))
y9[i] = rnorm(1, sample.theta9[i], sqrt(sigma2.mcmc[1, i, drop = TRUE]))
}
a_theta = summary(theta.mcmc)
post_means = a_theta$statistics[1:8, 1]
sample.theta9 =  rep(0, S)
for (i in 1:S){
sample.theta9[i] = rnorm(1, mu, sqrt(tau2.mcmc[i, 1, drop = TRUE]))
y7[i] = rnorm(1, theta.mcmc[i, 7, drop = TRUE], sqrt(sigma2.mcmc[i, 1, drop = TRUE]))
y9[i] = rnorm(1, sample.theta9[i], sqrt(sigma2.mcmc[i, 1, drop = TRUE]))
}
a_theta = summary(theta.mcmc)
post_means = a_theta$statistics[1:8, 1]
sample.theta9 =  rep(0, S)
for (i in 1:S){
sample.theta9[i] = rnorm(1, mu, sqrt(tau2.mcmc[i, drop = TRUE]))
y7[i] = rnorm(1, theta.mcmc[i, 7, drop = TRUE], sqrt(sigma2.mcmc[i, drop = TRUE]))
y9[i] = rnorm(1, sample.theta9[i], sqrt(sigma2.mcmc[i, drop = TRUE]))
}
a_theta = summary(theta.mcmc)
post_means = a_theta$statistics[1:8, 1]
sample.theta9 =  rep(0, S)
sample.y7 =  rep(0, S)
sample.y9 =  rep(0, S)
for (i in 1:S){
sample.theta9[i] = rnorm(1, mu, sqrt(tau2.mcmc[i, drop = TRUE]))
sample.y7[i] = rnorm(1, theta.mcmc[i, 7, drop = TRUE], sqrt(sigma2.mcmc[i, drop = TRUE]))
sample.y9[i] = rnorm(1, sample.theta9[i], sqrt(sigma2.mcmc[i, drop = TRUE]))
}
mc_theta = sum(sample.theta9 > theta.mcmc[1:S, 7]) / S
mc_y = sum(sample.y9 > sample.y7)/S
writeLines(paste("The Monte Carlo estimate given the original prior of theta[B] is:", mc_theta, "\nThe Monte Carlo estimate given the original prior of theta[B] is:", mc_y))
a_theta = summary(theta.mcmc)
post_means = a_theta$statistics[1:8, 1]
sample.theta9 =  rep(0, S)
sample.y7 =  rep(0, S)
sample.y9 =  rep(0, S)
for (i in 1:S){
sample.theta9[i] = rnorm(1, mu, sqrt(tau2.mcmc[i, drop = TRUE]))
sample.y7[i] = rnorm(1, theta.mcmc[i, 7, drop = TRUE], sqrt(sigma2.mcmc[i, drop = TRUE]))
sample.y9[i] = rnorm(1, sample.theta9[i], sqrt(sigma2.mcmc[i, drop = TRUE]))
}
mc_theta = sum(sample.theta9 > theta.mcmc[1:S, 7]) / S
mc_y = sum(sample.y9 > sample.y7)/S
writeLines(paste("The Monte Carlo estimate of the posterior probability of {theta9 > theta7} is:", mc_theta, "\nThe Monte Carlo estimate of the posterior predictive probability of {Y9 > Y7} is:", mc_y))
knitr::opts_chunk$set(echo = TRUE)
colorize <- function(x, color) {
if (knitr::is_latex_output())
sprintf("\\textcolor{%s}{%s}", color, x)
else if (knitr::is_html_output())
sprintf('<span style = "color: %s;">%s</span>', color, x)
else x
} # `r textit("red", "aaa")`
indicator <- function() {
if (knitr::is_latex_output())
sprintf("\\indicator")
else if (knitr::is_html_output())
sprintf("1")
else sprintf("1")
} #`r indicator()`
simiid <- function() {
if (knitr::is_latex_output())
sprintf("\\simiid")
else if (knitr::is_html_output())
sprintf("\\sim")
else sprintf("\\sim")
} #`r simiid()`
newline <- function() {
if (knitr::is_latex_output())
sprintf("\\")
else if (knitr::is_html_output())
sprintf("<br>")
else ""
} # `r newline()`
textit <- function(arg) {
if (knitr::is_latex_output())
sprintf("\\textit{%s}", arg)
else if (knitr::is_html_output())
sprintf("<i>%s</i>", arg)
else sprintf("%s", arg)
} # `r textit("aaa")`
textbf <- function(arg) {
if (knitr::is_latex_output())
sprintf("\\textbf{%s}", arg)
else if (knitr::is_html_output())
sprintf("<strong>%s</strong>", arg)
else sprintf("%s", arg)
} # `r textbf("aaa")`
begin_rcases <- function() {
if (knitr::is_latex_output())
sprintf("\\begin{rcases}")
else if (knitr::is_html_output())
sprintf("\\begin{array}{l}")
else ""
} # `r begin_rcases()`
end_rcases <- function() {
if (knitr::is_latex_output())
sprintf("\\end{rcases}")
else if (knitr::is_html_output())
sprintf("\\end{array} \\hspace{0.3cm}")
else ""
} # `r end_rcases()`
cancel <- function(x) {
if (knitr::is_latex_output())
sprintf("\\cancel{%s}", x)
else if (knitr::is_html_output())
sprintf("%s", x)
else sprintf("%s", x)
} # `r cancel("x")`
library(ggplot2)
library(coda)
library(truncnorm)
load(file = "./2_hw_bs/rmd/divorce.RData")
load("C:/Users/Thinkopen/OneDrive/Desktop/Carlo Alberto/Assignment/bayesian_statitistics_assignments/2_hw_bs/rmd/divorce.RData")
library(coda)
library(truncnorm)
load(file = "C:\Users\Thinkopen\OneDrive\Desktop\Carlo Alberto\Assignment\bayesian_statitistics_assignments\2_hw_bs\rmd\divorce.RData")
library(coda)
library(truncnorm)
load(file = ".\bayesian_statitistics_assignments\2_hw_bs\rmd\divorce.RData")
load("C:/Users/Thinkopen/OneDrive/Desktop/Carlo Alberto/Assignment/bayesian_statitistics_assignments/2_hw_bs/rmd/divorce.RData")
library(coda)
library(truncnorm)
load(file = "divorce.RData")
set.seed(1)
# setting parameters
burnin = 1e3
tmax = burnin + 1e3
n = 25
# build and upload: beta, c, z_1:n, y_1:n
beta = c = matrix(0, 1, tmax)
z = y = matrix(0, n, tmax)
x = matrix(0, n, 1)
x[, 1] = divorce[, "X"]
y[, 1] = divorce[, "Y"]
# parameters for priors and full conditionals distributions
mu_beta = matrix(0, 1, tmax)
mu_beta[1] = 0
mu_c = 0
sigma_sq_beta = sigma_sq_c = 16
sigma_sq_beta_n = (sum(x^2) + (sigma_sq_beta)^(-1))^(-1)
a = matrix(-Inf, 1, tmax)
b = matrix(Inf, 1, tmax)
# prior samples
beta[1] = rnorm(1, mu_beta[1], sqrt(sigma_sq_beta))
c[1] = rnorm(1, mu_c, sqrt(sigma_sq_c))
# z[, 1] = rnorm(n, beta[1] * x, rep(1, n))
# y[, 1] = 1 * (z[, 1] > c[1])
# mcmc
for (t in 2:(tmax)) {
# z
lower_bound = rep(c[t - 1], n)
lower_bound[y[, t - 1] == 0] = -Inf
upper_bound = rep(c[t - 1], n)
upper_bound[y[, t - 1] == 1] = +Inf
z[, t] = rtruncnorm(n, lower_bound, upper_bound, beta[t - 1] * x, rep(1, n))
# update y (useless because they follow the behaviour of z which is sampled given y)
y[, t] = 1 * (z[, t] > c[t - 1])
# beta
mu_beta[t] = sigma_sq_beta_n * sum(x * z[, t])
beta[t] = dnorm(1, mu_beta[t], sqrt(sigma_sq_beta_n))
# c
a[t] = max(z[, t][y[, t] == 0])
b[t] = min(z[, t][y[, t] == 1])
c[t] = rtruncnorm(1, a[t], b[t], mu_c, sqrt(sigma_sq_c))
# update y (useless because they follow the behaviour of z which is sampled given y)
y[, t] = 1 * (z[, t] > c[t])
# break if eff_size > 1000 (for all params)
if (t > burnin && effectiveSize(c[1, -c(1:burnin)]) > 1000) {
print(t)
break
}
}
