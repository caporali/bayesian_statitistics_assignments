# break if eff_size > 1000 (for all params)
if (t > burnin + 1 & (t %% 1000 == 0)) {
if (effectiveSize(c[c((burnin + 1):t)]) > 1000 &
# effectiveSize(beta[c((burnin + 1):t)]) > 1000 &
prod(effectiveSize(z[c((burnin + 1):t), ]) > 1000) == 1)
{
c = c[c((burnin + 1):t)]
beta = beta[c((burnin + 1):t)]
z = z[c((burnin + 1):t), ]
break
}
}
}
# mcmc
params = cbind(beta, c, z)
params <- setNames(beta, c, paste0("z", 1:25))
color_scheme_set("green")
# autocorrelation function of beta
mcmc_acf(as.data.frame(params), pars = c("beta", "c"), lags = 50, facet_args = list(nrow = 4, labeller = label_parsed))+
theme_bw()+
xlab(" ")
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c("z"), lags = 50)+
theme_bw()
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c(""), lags = 50)+
theme_bw()
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), lags = 50)+
theme_bw()
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c(paste("V", 1:25)) lags = 50)+
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c(paste("V", 1:25)), lags = 50)+
theme_bw()
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c(paste("V", 1:25, collapse = "")), lags = 50)+
theme_bw()
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c(sep(paste("V", 1:25, collapse = ","), sep = ",")), lags = 50)+
theme_bw()
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c(cut(paste("V", 1:25, collapse = ","), sep = ",")), lags = 50)+
theme_bw()
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c(paste("V", 1:25, sep = "")), lags = 50)+
theme_bw()
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c(paste("V", 3:27, sep = "")), lags = 50)+
theme_bw()
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c(paste("V", 3:8, sep = "")), lags = 50)+
theme_bw()
mcmc_acf(as.data.frame(params), pars = c(paste("V", 9:14, sep = "")), lags = 50)+
theme_bw()
mcmc_acf(as.data.frame(params), pars = c(paste("V", 15:20, sep = "")), lags = 50)+
theme_bw()
mcmc_acf(as.data.frame(params), pars = c(paste("V", 21:27, sep = "")), lags = 50)+
theme_bw()
#theta
color_scheme_set("blue")
p1 <- mcmc_trace(as.data.frame(theta.mcmc), pars = c(paste("V", 1:4, sep = "")), facet_args = list(nrow = 4, labeller = label_parsed))+
ggtitle(expression(paste("Traceplots of ", theta[1:4])))+
scale_y_continuous(breaks = c(4, 6, 8 ,10, 12, 14))
p2 <- mcmc_areas(as.data.frame(theta.mcmc), pars = c(paste("V", 1:4, sep = "")), prob = 0.95,
prob_outer = 1,
point_est = "mean") +
ggtitle(expression(paste("Density plots of the posteriors for ", theta[1:4])))
grid.arrange(p1, p2, nrow = 1)
p1 <- mcmc_trace(as.data.frame(theta.mcmc), pars = c(paste("V", 5:8, sep = "")), facet_args = list(nrow = 4, labeller = label_parsed))+
ggtitle(expression(paste("Traceplots of ", theta[5:8])))+
scale_y_continuous(breaks = c(4, 6, 8 ,10, 12, 14))
p2 <- mcmc_areas(as.data.frame(theta.mcmc), pars = c(paste("V", 5:8, sep = "")), prob = 0.95,
prob_outer = 1,
point_est = "mean") +
ggtitle(expression(paste("Density plots of the posteriors for ", theta[5:8])))
grid.arrange(p1, p2, nrow = 1)
#comparison
theme_update(plot.title = element_text(hjust = 0.5))
color_scheme_set("purple")
q1 <- mcmc_trace(as.data.frame(mu.mcmc))+
ggtitle(expression(mu))+
yaxis_title(on = FALSE)
q2<- mcmc_areas(
as.data.frame(mu.mcmc),
prob = 0.95,
prob_outer = 1,
point_est = "mean")+
ggtitle(expression(mu))+
yaxis_text(on = FALSE)
color_scheme_set("red")
q3 <- mcmc_trace(as.data.frame(sigma2.mcmc))+
ggtitle(expression(sigma^2))+
yaxis_title(on = FALSE)
q4 <- mcmc_areas(
as.data.frame(sigma2.mcmc),
prob = 0.95,
prob_outer = 1,
point_est = "mean")+
ggtitle(expression(sigma^2))+
yaxis_text(on = FALSE)
color_scheme_set("teal")
q5 <- mcmc_trace(as.data.frame(tau2.mcmc))+
ggtitle(expression(tau^2))+
yaxis_title(on = FALSE)
q6 <- mcmc_areas(
as.data.frame(tau2.mcmc),
prob = 0.95,
prob_outer = 1,
point_est = "mean")+
ggtitle(expression(tau^2))+
yaxis_text(on = FALSE)
grid.arrange(q1, q2, q3, q4, q5, q6, nrow = 3, top=textGrob("Traceplots and density plots"))
S_mu = effectiveSize(mu.mcmc)
S_sigma2 = effectiveSize(sigma2.mcmc)
S_tau2 = effectiveSize(tau2.mcmc)
S_theta = effectiveSize(theta.mcmc)
# autocorrelation function of c
mcmc_acf(as.data.frame(params), pars = "c", lags = 50, facet_args = list(nrow = 2, labeller = label_parsed))+
theme_bw()
color_scheme_set("green")
# autocorrelation function of beta
mcmc_acf(as.data.frame(params), pars = "beta", lags = 50)+
theme_bw()+
xlab(" ")
library(ggrepel)
mean_plt = data.frame(post_means, ybar, names = 1:8)
mean_plt %>% ggplot(aes(x=post_means, y = ybar))+
geom_point( col = "green")+
geom_line(col = "darkgreen", alpha = 0.5, size = 1)+
geom_hline(yintercept = a_mu$statistics[1], col = "orange", size = 0.8)+
ylab(expression(y[i])) +
xlab(expression(paste(theta[i]))) +
ggtitle(expression(paste("Posterior mean parameters ", theta[i], " VS sample means ", y[i])))+
scale_color_discrete(guide = "none")+
geom_label_repel(aes(label = names),
box.padding   = 0.35,
point.padding = 0.5,
segment.color = 'grey50')
total.sample.mean = sum(n*ybar)/sum(n)
knitr::opts_chunk$set(echo = TRUE)
colorize <- function(x, color) {
if (knitr::is_latex_output())
sprintf("\\textcolor{%s}{%s}", color, x)
else if (knitr::is_html_output())
sprintf('<span style = "color: %s;">%s</span>', color, x)
else x
} # `r textit("red", "aaa")`
indicator <- function() {
if (knitr::is_latex_output())
sprintf("\\indicator")
else if (knitr::is_html_output())
sprintf("1")
else sprintf("1")
} #`r indicator()`
simiid <- function() {
if (knitr::is_latex_output())
sprintf("\\simiid")
else if (knitr::is_html_output())
sprintf("\\sim")
else sprintf("\\sim")
} #`r simiid()`
newline <- function() {
if (knitr::is_latex_output())
sprintf("\\")
else if (knitr::is_html_output())
sprintf("<br>")
else ""
} # `r newline()`
textit <- function(arg) {
if (knitr::is_latex_output())
sprintf("\\textit{%s}", arg)
else if (knitr::is_html_output())
sprintf("<i>%s</i>", arg)
else sprintf("%s", arg)
} # `r textit("aaa")`
textbf <- function(arg) {
if (knitr::is_latex_output())
sprintf("\\textbf{%s}", arg)
else if (knitr::is_html_output())
sprintf("<strong>%s</strong>", arg)
else sprintf("%s", arg)
} # `r textbf("aaa")`
begin_rcases <- function() {
if (knitr::is_latex_output())
sprintf("\\begin{rcases}")
else if (knitr::is_html_output())
sprintf("\\begin{array}{l}")
else ""
} # `r begin_rcases()`
end_rcases <- function() {
if (knitr::is_latex_output())
sprintf("\\end{rcases}")
else if (knitr::is_html_output())
sprintf("\\end{array} \\hspace{0.3cm}")
else ""
} # `r end_rcases()`
cancel <- function(x) {
if (knitr::is_latex_output())
sprintf("\\cancel{%s}", x)
else if (knitr::is_html_output())
sprintf("%s", x)
else sprintf("%s", x)
} # `r cancel("x")`
library(ggplot2)
library(coda)
library(truncnorm)
library(bayesplot)
library(ggplot2)
library(gridExtra)
library(lattice)
library(grid)
library(dplyr)
load(file = "divorce.RData")
set.seed(1)
# setting parameters
burnin = 1e3
tmax = burnin + 1e5
n = 25
# build and upload: beta, c, z_1:n, y_1:n
beta = c = matrix(0, tmax, 1)
z = y = matrix(0, tmax, n)
x = matrix(0, 1, n)
x[1, ] = divorce[, "X"]
y[1, ] = divorce[, "Y"]
# parameters for priors and full conditionals distributions
mu_beta = matrix(0, tmax, 1)
mu_beta[1] = 0
mu_c = 0
sigma_sq_beta = sigma_sq_c = 16
sigma_sq_beta_n = (sum(x^2) + (sigma_sq_beta)^(-1))^(-1)
a = matrix(-Inf, tmax, 1)
b = matrix(Inf, tmax, 1)
# prior samples
beta[1] = rnorm(1, mu_beta[1], sqrt(sigma_sq_beta))
c[1] = rnorm(1, mu_c, sqrt(sigma_sq_c))
# gibbs sampler
for (t in 2:(tmax)) {
# z
lower_bound = rep(c[t - 1], n)
lower_bound[y[t - 1, ] == 0] = -Inf
upper_bound = rep(c[t - 1], n)
upper_bound[y[t - 1, ] == 1] = +Inf
z[t, ] = rtruncnorm(n, lower_bound, upper_bound, beta[t - 1] * x, rep(1, n))
# update y (redundant because they follow the behaviour of z which is sampled given y)
y[t, ] = 1 * (z[t, ] > c[t - 1])
# beta
mu_beta[t] = sigma_sq_beta_n * sum(x * z[t, ])
beta[t] = dnorm(1, mu_beta[t], sqrt(sigma_sq_beta_n))
# c
a[t] = max(z[t, ][y[t, ] == 0])
b[t] = min(z[t, ][y[t, ] == 1])
c[t] = rtruncnorm(1, a[t], b[t], mu_c, sqrt(sigma_sq_c))
# re-update y (redundant because they follow the behaviour of z which is sampled given y)
y[t, ] = 1 * (z[t, ] > c[t])
# break if eff_size > 1000 (for all params)
if (t > burnin + 1 & (t %% 1000 == 0)) {
if (effectiveSize(c[c((burnin + 1):t)]) > 1000 &
# effectiveSize(beta[c((burnin + 1):t)]) > 1000 &
prod(effectiveSize(z[c((burnin + 1):t), ]) > 1000) == 1)
{
c = c[c((burnin + 1):t)]
beta = beta[c((burnin + 1):t)]
z = z[c((burnin + 1):t), ]
break
}
}
}
# mcmc
params_mcmc = mcmc(cbind(beta, c, z))
color_scheme_set("green")
# autocorrelation function of beta
mcmc_acf(as.data.frame(params), pars = "beta", lags = 50)+
theme_bw()+
xlab(" ")
# autocorrelation function of c
mcmc_acf(as.data.frame(params), pars = "c", lags = 50, facet_args = list(nrow = 2, labeller = label_parsed))+
theme_bw()
# autocorrelation function of z (i = 15 taken as an example)
mcmc_acf(as.data.frame(params), pars = c(paste("V", 3:8, sep = "")), lags = 50)+
theme_bw()
mcmc_acf(as.data.frame(params), pars = c(paste("V", 9:14, sep = "")), lags = 50)+
theme_bw()
mcmc_acf(as.data.frame(params), pars = c(paste("V", 15:20, sep = "")), lags = 50)+
theme_bw()
mcmc_acf(as.data.frame(params), pars = c(paste("V", 21:27, sep = "")), lags = 50)+
theme_bw()
set.seed(1)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(0, nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(rep(0, S))
mu.mcmc = mcmc(rep(0, S))
tau2.mcmc = mcmc(rep(0, S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
if (s > burnin + 10 &
effectiveSize(mu.mcmc) >= 1000 &
effectiveSize(tau2.mcmc) >= 1000 &
effectiveSize(sigma2.mcmc) >= 1000 &
prod(effectiveSize(theta.mcmc) >= 1000) == 1)
{
break
}
}
}
set.seed(1)
load(file = "schools.RData")
# Prior parameters
mu0 = 7
g20 = 5
t20 = 10
eta0 = 2
s20 = 15
nu0 = 2
# Number of schools. Y[, 1] are school ids
m = length(unique(Y[, 1]))
# Starting values - use sample mean and variance
sv = double(length = m)
ybar = double(length = m)
n = integer(length = m)
for (j in 1:m) {
Y_j = Y[Y[, 1] == j, 2]
ybar[j] = mean(Y_j)
sv[j] = var(Y_j)
n[j] = length(Y_j)
}
# Let initial theta estimates be the sample means
# Similarly, let initial values of sigma2, mu, and tau2 be "sample mean and variance"
theta = ybar
sigma2 = mean(sv)
mu = mean(theta)
tau2 = var(theta)
# MCMC
burnin = 1e3
S = 5e3
theta.mcmc = mcmc(matrix(0, nrow = S, ncol = m)) # declare them as mcmc objects
# Storing sigma, mu, theta
sigma2.mcmc = mcmc(rep(0, S))
mu.mcmc = mcmc(rep(0, S))
tau2.mcmc = mcmc(rep(0, S))
for (s in 1:(burnin+S)) {
# Sample thetas
for (j in 1:m) {
vtheta = 1 / (n[j] / sigma2 + 1 / tau2)
etheta = vtheta * (ybar[j] * n[j] / sigma2 + mu / tau2)
theta[j] = rnorm(1, etheta, sqrt(vtheta))
}
# Sample sigma2
nun = nu0 + sum(n)
ss = nu0 * s20
# Pool variance
for (j in 1:m) {
ss = ss + sum((Y[Y[, 1] == j, 2] - theta[j])^2)
}
sigma2 = 1 / rgamma(1, nun / 2, ss / 2)
# Sample mu
vmu = 1 / (m / tau2 + 1 /g20)
emu = vmu * (m * mean(theta) / tau2 + mu0 / g20)
mu = rnorm(1, emu, sqrt(vmu))
# Sample tau2
etam = eta0 + m
ss = eta0 * t20 + sum((theta - mu)^2)
tau2 = 1 / rgamma(1, etam / 2, ss / 2)
# Store params
if(s > burnin){
theta.mcmc[s-burnin, ] = theta
sigma2.mcmc[s-burnin] = sigma2
mu.mcmc[s-burnin] = mu
tau2.mcmc[s-burnin] = tau2
if (s > burnin + 10 &
effectiveSize(mu.mcmc) >= 1000 &
effectiveSize(tau2.mcmc) >= 1000 &
effectiveSize(sigma2.mcmc) >= 1000 &
prod(effectiveSize(theta.mcmc) >= 1000) == 1)
{
break
}
}
}
color_scheme_set("green")
# autocorrelation function of beta
mcmc_acf(as.data.frame(params_mcmc), pars = c("beta", "c"), lags = 50, facet_args = list(nrow = 2, labeller = label_parsed))+
theme_bw()+
xlab(" ")
#posterior of R obtained through MC sampling
sample.r.post = rep(0, s)
sample.r.prior = rep(0, s)
sample.sigma2.prior = rinvgamma(s, eta0/2, eta0*t20/2)
sample.tau2.prior = rinvgamma(s, nu0/2, nu0*s20/2)
for (i in 1:s){
sample.r.post[i] = tau2.mcmc[i, drop = TRUE] /(sigma2.mcmc[i, drop = TRUE] + tau2.mcmc[i, drop = TRUE] )
sample.r.prior[i] = sample.tau2.prior[i]/(sample.tau2.prior[i] + sample.sigma2.prior[i])
}
sample_r = data.frame(sample.r.prior, sample.r.post)
sample_r %>% ggplot()+
geom_density(aes(x = sample.r.prior, col = "prior"), fill = "red", alpha = 0.3, size = 0.8)+
geom_density(aes(x = sample.r.post, col="posterior"), fill = "blue", alpha = 0.3, size = 0.8)+
scale_color_manual(name = "Legend", values = c("prior" = "red", "posterior" = "blue"),
labels = c("prior distribution", "posterior distribution"))+
ylab(" ") +
xlab(" ") +
ggtitle("Posterior density VS Prior density for parameter R ")
#posterior of R obtained through MC sampling
sample.r.post = rep(0, s)
sample.r.prior = rep(0, s)
sample.sigma2.prior = rinvgamma(s, eta0/2, eta0*t20/2)
sample.tau2.prior = rinvgamma(s, nu0/2, nu0*s20/2)
for (i in 1:s){
sample.r.post[i] = tau2.mcmc[i, drop = TRUE] /(sigma2.mcmc[i, drop = TRUE] + tau2.mcmc[i, drop = TRUE] )
sample.r.prior[i] = sample.tau2.prior[i]/(sample.tau2.prior[i] + sample.sigma2.prior[i])
}
sample_r = data.frame(sample.r.prior, sample.r.post)
sample_r %>% ggplot()+
geom_density(aes(x = sample.r.prior, col = "prior", fill = "red"), alpha = 0.3, size = 0.8)+
geom_density(aes(x = sample.r.post, col="posterior", fill = "blue"), alpha = 0.3, size = 0.8)+
scale_color_manual(name = "Legend", values = c("prior" = "red", "posterior" = "blue"),
labels = c("prior distribution", "posterior distribution"))+
ylab(" ") +
xlab(" ") +
ggtitle("Posterior density VS Prior density for parameter R ")
#posterior of R obtained through MC sampling
sample.r.post = rep(0, s)
sample.r.prior = rep(0, s)
sample.sigma2.prior = rinvgamma(s, eta0/2, eta0*t20/2)
sample.tau2.prior = rinvgamma(s, nu0/2, nu0*s20/2)
for (i in 1:s){
sample.r.post[i] = tau2.mcmc[i, drop = TRUE] /(sigma2.mcmc[i, drop = TRUE] + tau2.mcmc[i, drop = TRUE] )
sample.r.prior[i] = sample.tau2.prior[i]/(sample.tau2.prior[i] + sample.sigma2.prior[i])
}
sample_r = data.frame(sample.r.prior, sample.r.post)
sample_r %>% ggplot()+
geom_density(aes(x = sample.r.prior, col = "prior", fill = "prior"), alpha = 0.3, size = 0.8)+
geom_density(aes(x = sample.r.post, col="posterior", fill = "posterior"), alpha = 0.3, size = 0.8)+
scale_color_manual(name = "Legend", values = c("prior" = "red", "posterior" = "blue"),
labels = c("prior distribution", "posterior distribution"))+
ylab(" ") +
xlab(" ") +
ggtitle("Posterior density VS Prior density for parameter R ")
#posterior of R obtained through MC sampling
sample.r.post = rep(0, s)
sample.r.prior = rep(0, s)
sample.sigma2.prior = rinvgamma(s, eta0/2, eta0*t20/2)
sample.tau2.prior = rinvgamma(s, nu0/2, nu0*s20/2)
for (i in 1:s){
sample.r.post[i] = tau2.mcmc[i, drop = TRUE] /(sigma2.mcmc[i, drop = TRUE] + tau2.mcmc[i, drop = TRUE] )
sample.r.prior[i] = sample.tau2.prior[i]/(sample.tau2.prior[i] + sample.sigma2.prior[i])
}
sample_r = data.frame(sample.r.prior, sample.r.post)
sample_r %>% ggplot()+
geom_density(aes(x = sample.r.prior, col = "prior"), fill = "red", alpha = 0.3, size = 0.8)+
geom_density(aes(x = sample.r.post, col="posterior"), fill = "blue", alpha = 0.3, size = 0.8)+
scale_color_manual(name = "Legend", values = c("prior" = "red", "posterior" = "blue"),
labels = c("prior distribution", "posterior distribution"))+
ylab(" ") +
xlab(" ") +
ggtitle("Posterior density VS Prior density for parameter R ")
